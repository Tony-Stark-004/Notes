{
	"nodes":[
		{"id":"11d9a31d7b3d12ca","x":-560,"y":-280,"width":900,"height":700,"type":"text","text":"# Kubernetes Networking\n### Container communication\n\n* #### Why Pod abstraction over docker container is useful \n\nNOTE: because one port of container mapped to one port of host so keeping in mind which container port is already mapped with which host post is difficult can cause conflict at larger level where multiple containers is involved in this case Pod is very useful\n\n* Every Pod has a unique IP address\n* IP address should reachable from all other pods in the K8s cluster\n* Pod has own network namespace and virtual ethernet connection. Meaning Pod is host just like our machine\n\t* Both Pod and our Host machine e.g. Laptop or Pc has IP address and range of ports to allocate\n* One single Pod can contain 6 container max.\n* You can replace container Run-time easily because it is the Pod which interact not abstract container inside it so you can replace Docker with Vagrant which also the containerized tool.\n\n#####  Multiple container in Pod\nNote: Because Pod is an isolated virtual host with its own Network Namespace and container insides all run in this network namespace which means that container can talk via localhost and port number\n\n##### Let's perform the practical\n"},
		{"id":"e033dc63739cc8e7","type":"text","text":"##### Let's create One Nginx container and inside that in `container` part let's add another container\n* `nginx-sidecar.yaml` is Pod configuration file name\n\n```\napiVersion: v1\nkind: Pod\nmetadata:\n\tname: nginx\n\tlabels: \n\t\tapp: nginx\nspec: \n\tcontainers: \n\t- name: nginx-container\n\t  image: nginx\n\t  ports: \n\t  - containerPort: 80\n\t- name: sidecar\n\t  image: curlimages/curl\n\t  command: [\"/bin/sh\"]\n\t  args: [\"-c\", \"echo Hello from the sidecar container; sleep 300\"]\n\n```\n\nNow, let's create Pod using this configuration file\n\n```\n1. kubectl apply -f nginx-sidecar.yaml\n\nNow let's enter inside curl container\n\n2. kubectl exec -it <pod-name> -c <container-name> -- /bin/sh\n\t1. kubectl exec -it nginx -c sidecar -- /bin/sh\n\t2. here -c is used for specifying container meaning on which container you are targetting\n\nAlso on running step-2 command you will get inside it now, run\n* neststat -ln\n\t* This command show internet connection details\n* curl localhost:80 you will the nginx degault html page\n```","x":360,"y":-280,"width":920,"height":1000,"color":"4"},
		{"id":"739b07edb3594cb3","x":-80,"y":-360,"width":700,"height":65,"color":"3","type":"text","text":"# Pods and Containers - Kubernetes Networking"},
		{"id":"45ad109fdce8e73a","x":-560,"y":-1000,"width":860,"height":600,"color":"3","type":"text","text":"# pause container\n* There is `pause container` inside each Pod and also called `sandbox` container. And it's job is to reserve and holds Pods network namespace that is shared by all the container in the pod.\n* Pause container enables communication between container\n* also if `main container` is deleted and when new container is come at deleted container place Pod IP is intact because of `Pause container`\n* Only if Pod is died and new Pod is recreated which get new IP address\n\nLet's see where we find the `Pause container`\n```\n1. echo $(minikube docker-env)\n\n2. eval $(minikube docker-env)\n** Telling docker to execute docker command on remote host which is minikube ** Because minikube is run in virtual machine and we need to connect host machine to remote host which is minikube so to do that we ran the above command.\n\n3. docker ps | grep k8_POD_nginx\n** You will see the pause container\n\n```"}
	],
	"edges":[]
}