{
	"nodes":[
		{"id":"36bf84308f745270","type":"text","text":"# Kubernetes YAML File Explained","x":-240,"y":-360,"width":520,"height":60,"color":"3"},
		{"id":"821520a57744bb05","type":"text","text":"# Kubernetes YAML File \nEach configuration file has 3 parts\n* Metadata\n* specification\n* status\n#### Metadata\nhere all metadata of components comes up like\n* name\n* label\n\n#### Specification\nhere all the actual configuration of components comes up\n* attributes of specification are specific to the kind meaning specification attributes is different for Deployment component and different for Services components\n\n#### Status\nstatus inside the configuration file is automatically generated and added Kubernetes \n\n------ Working of status attribute -----\n* It compares between desired state and actual state and if there is any change then it try to resolve it. This is the self healing feature that Kubernetes provides\n\n------ Where does Kubernetes get this status data -----\n* It is stored inside `etcd process also called cluster brain`  which is the part of master node and comes from there","x":-680,"y":-1280,"width":813,"height":899,"color":"4"},
		{"id":"81bc5d52e81b4735","type":"text","text":"# Configuration file for Deployment component\n* We are using nginx image\n* also configuration file is `.yaml` extension and use `apply command` to execute\n* `.yaml` file indentation is very important \n* `nginx-deployment.yaml` is file name\n\n```\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n\tname: nginx-deployment\n\tlabels: \n\t\tapp: nginx\nspec: \n\treplicas: 2\n\tselector: \n\t\tmatchLabel: \n\t\t\tapp: nginx\n\ttemplate:\n\t\tmetadata:\n\t\t\tlabels:\n\t\t\t\tapp: nginx\n\t\tspec:\n\t\t\tcontainers: \n\t\t\t- name: nginx\n\t\t\t  image: nginx:1.16\n\t\t\t  ports: \n\t\t\t  - containerPort: 8080\n```\n\n# Connecting Deployment to Pods\n* Connection is established between the components using `labels` and `selectors`\n* `metadata` part contains the `labels` and `spec`  parts contains the `selector`\n* In `metadata --> labels` we give components like `Deployment` and `Service` any `key-pair` here we gave `app: nginx` key-pair can be anything keep in mind\n\nHere,\n`template` which is used to configure `pods` also we can say that it is blueprint for `pods` have `metadata labels` and `Deployment component` have `spec --> selector` so here `selector --> matchLabels` attribute matches the `template attribute meaning Pod --> metadata --> labels --> key-pair and not its own label` which established the connection between `Deployment` and `Pod` and which determine which `Pod` belong to which `Deployment component` \n\nNOTE: \n* Each component have `metadata --> labels` and `spec --> selector`.  `metadata --> labels` are matched by other components `spec --> selector` to established the connection. \n* matching `metadata --> labels` and `spec --> selector` of `same components` cause error\n","x":-720,"y":-280,"width":813,"height":1240,"color":"5"},
		{"id":"627477f0f9ac4ac6","type":"text","text":"# Layers of Abstraction\n\n`Deployment` manages a ..\n`ReplicateSet` manages a ..\n`Pod` is an abstraction of ..\n`Container`\n\nNOTE: \n* Whenever we want to create `Pod` we actually create deployment and it will take care the rest\n* Also changes inside deployments cascade down to all the `Pods` that it manages","x":160,"y":-701,"width":760,"height":320,"color":"1"},
		{"id":"82b4db7caa938451","type":"text","text":"#### Some important points\n* `apiVersion` is used to give version to our Deployment component \n* ***\n\n* `kind` is which Kubernetes component it is in our case it is `Deployment`\n* ***\n\n* `metadata` parts contain `labels` which is used to connect with other Kubernetes components\n* ***\n\n* `spec` is parts where actual configuration of components is\n***\n\n* `replicas` meaning how many `Pod` you want \n***\n\n* `selector` parts container `matchLabel` which is used to connect with other Kubernetes components. It checks for the `labels` if `labels --> key-value`  matches the `matchLabel key-value` then connection established and also it determine which components belongs to which components\n***\n\n* `template` is used to configure the `Pods` inside `Deployment` . Never forget main goal of `Deployment file` is to create the `Pod`. `template` also have its own `spec and metadata` because `template` is for `Pod` and `Pod` itself is a `Kubernetes components`. Meaning `template attribute` can be used to configure `other component` inside the `components file`","x":-1680,"y":-280,"width":820,"height":800,"color":"2"},
		{"id":"628ba4a4df2f71df","type":"text","text":"# Configuration file for Service component\n* We are using nginx image\n* also configuration file is `.yaml` extension and use `apply command` to execute\n* `nginx-service.yaml` is file name\n\n```\napiVersion: apps/v1\nkind: Service\nmetadata:\n\tname: nginx-service\nspec: \n\tselector: \n\t\tapp: nginx\n\tports: \n\t\t- protocol: TCP\n\t\t  port: 80\n\t\t  targetPort: 8080\n\t\n\t\n```\n\n`Deployment component` also contain `metadata --> labels --> key-pair` which we previously used to established the connection with `Pods` It can also we used to establish the connection with `Service components` meaning any Kubernetes components.\n\n* `selector` of `Service component` matches the `Deployment component metadata --> labels --> key-pair` so connection will establish successfully\n\n#### Important: See the Ports attribute it contains\n* `protocol` meaning which protocol are we using\n* `port: 80` meaning Service itself is accessible at port `80`\n* `targetPort: 8080` because service component gives Permanent IP addresses to Pods and forward request to `Pods` because it also act as `Load balancer` so services needs to know to which `Pod` it should forward the request but also at which port is that `Pod` listening. so that's for `ports --> targetPort: 8080`. And `targetPort: 8080` should matches the `template attribute --> port --> containerPort: 8080` You can see in `Deployment component configuration file`","x":107,"y":-280,"width":893,"height":960,"color":"5"},
		{"id":"567878cf632cc8c6","type":"text","text":"#### Let's create Deployment and Service using respective configuration file\n\n1. `kubectl apply -f nginx-deployment.yaml`\n\t1. basically we are creating deployments and pods using `nginx-deployment.yaml` configuration file\n\t2. `kubectl get deployment`\n\t3. `kubectl get pod`\n2. `kubectl apply -f nginx-service.yaml`\n\t1. creating `service component`\n\t2. `kubectl get service` \n\t\t1. to see present Kubernetes services inside cluster\n3. `kubectl delete -f nginx-deployment.yaml`\n\t1. to delete Kubernetes deployment component\n4. `kubectl delete -f nginx-service.yaml`\n\t1. to delete Kubernetes service component\n\nalso \n\n```\n1. kubectl describe service <service-name>\n\t1. kubectl describe service nginx-service\n\nThis command shows service has right Pods that it forwards the request to\n```\n\n```\n1. kubectl get pod -o wide\n\n-o meaning output basically it give the pod details along with IP addresses assign to Pods\n```\n\n```\n1. kubectl get deployment <deployment-name> -o yaml\n\nSo what it does it give you the yaml configuration file that we configure for deployment components with autogenerated status attribute which reside in the etcd process\n```","x":107,"y":700,"width":853,"height":840,"color":"3"}
	],
	"edges":[
		{"id":"eb72fe9419759a8c","fromNode":"82b4db7caa938451","fromSide":"right","toNode":"81bc5d52e81b4735","toSide":"left"}
	]
}