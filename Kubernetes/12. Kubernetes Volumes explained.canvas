{
	"nodes":[
		{"id":"3ba8be57c991d091","type":"text","text":"# Kubernetes Volumes explained\nKubernetes volumes use to persist the data.\nThe three component of Kubernetes component is\n* Persistent Volume\n* Persistent Volume Claim\n* Storage Class\n\nNote: Kubernetes do not give the data persistence feature. We need to explicitly configure for each application.\n\nImportant point to keep in mind for persistent volumes\n1. Storage that doesn't depend on the Pod lifecycle. \n2. Storage must be available on all nodes. because we don't know on which node our new Pod is restart\n3. Storage needs to survive even if cluster crashes.\n\n\n","x":-800,"y":-280,"width":820,"height":460},
		{"id":"f58e711a636607ca","type":"text","text":"# Local vs Remote Volume types\n\nNote: Each volume type has it's own use case\nLocal volumes types violet 2. and 3 requirement for data persistence which is\n* Being tied to 1 specific node\n* surviving cluster crashes\n\nBecause of these reasons for DB persistence we should always use Remote storage\n\nAlso, Storage resources is provisioned by Admin. And creating the Persistent volume component from available storage backends\n\nAnd then,\nDeveloper make `.yaml configuration file` to use those Persistent volume that is provisioned by admin.\nAnd developer need persistent volume claim which is also a `.yaml file`. Persistent volume claim (PVC) claims the persistent volume and which persistent volume matches the claim those persistent volume is being used by application\n\n* Also whenever we want to use volumes we need to specify the claim in `Pod configuration` \n\nThis is the `Persistent volume claim confifuration file`\n```\nkind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n\tname: pvc-name\nspec:\n\tstorageClassName: manual\n\tvolumeMode: filesystem\n\taccessModes: \n\t\t- ReadWriteOnce\n\tresources:\n\t\trequests:\n\t\t\tstorage: 10Gi\n```\n\nNow let's make Pod which uses the `PVC`\n```\napiVersion: v1\nkind: Pod\nmetadata:\n\tname: mypod\nspec: \n\tcontainers: \n\t- name: myfrontend\n\t  image: nginx\n\t  volumeMounts: \n\t  - mountPath: \"/var/www/html\"\n\t    name: mypod\n\tvolumes:\n\t\t- name: mypod\n\t\t  persistentVolumeClaim:\n\t\t\t  claimName: pvc-name\n\n```\n\n`persistentVolumeClaim` is the attribute where `PVC` is used see `pvc-name` is the `PVC name` which we has given to `PVC component`\n\nHere `volume attribute` is used to specify what volumes to provide\nand `volumeMounts attribute` is used to specify where to mount those in the container\nalso, `mountPath: \"/var/www/html\"` is the path where Apps can access the mounted data\n\nNOTE: `Pod and Claim` should be same namesapce","x":40,"y":-280,"width":820,"height":1600,"color":"3"},
		{"id":"353c6cc8fa90e41e","type":"text","text":"# Persistent Volume\nThis component of Kubernetes is used to store the data from which our application which is present in Pod container can read and write data from `Persistent volume`\n\n* Persistent volume is cluster resources just like RAM and CPU used to store data\n* Persistent volume just like any other Kubernetes Component is created via `YAML file`\n* Persistent volume is abstract component. It must take storage from actual physical storage like `local hardrive, external nfs server,  cloud storage like EBS`\n* Persistent volume is not namespaced meaning it is accessible to the whole cluster\n\n##### Where does this storage come from and who makes it available to the cluster\n\n* Kubernetes does not care about external storage. Storage is external plugin to our cluster. Kubernetes only provide volume component which is act as interface  between storage and Kubernetes cluster\n","x":-800,"y":200,"width":820,"height":440},
		{"id":"8bfd24523fbd4c1f","type":"text","text":"Claim tries to find a volume in cluster","x":-240,"y":800,"width":240,"height":74},
		{"id":"31d02342c8186ff6","type":"text","text":"Pod requests the volume through the PV claim","x":-240,"y":680,"width":240,"height":74},
		{"id":"fc06c63200010c0f","type":"text","text":"Volume has the actual storage backend","x":-240,"y":920,"width":240,"height":74},
		{"id":"12d1dfe2cc445c01","type":"text","text":"##### NOTE: `ConfigMap and Secret` is `Local volumes` and managed by Kubernetes\n\n* Mounting the `ConfigMap` and `Secret` component is same as we mount `PVC` in `Pod`\n* Here using variables that define inside `ConfigMap and Secret` in Pod is different as used it as Local Volume \n\n\nHere, One `Pod` can also mount many volumes simultaneously\n\n![[Pasted image 20250111032543.png]]\n\nAs you can see `volume attribute` it clearly shows that attribute is different for different volume type meaning for `configmap, secret and amazonElasticBLockStore` configuration is different","x":940,"y":-280,"width":940,"height":1600},
		{"id":"3e8fc92d4ae5986f","type":"text","text":"# Storage class (SC)\nBasically if we need 100 of Persistent volume then provisioning 100 volumes by admin is tedious in case `Storage class` is helpful \n\n* SC provisions Persistent Volumes dynamically whenever `PersistentVolumeClaim` claims it. This way provisioning volumes in cluster may be automated\n* SC also get created using `.yaml file`\n\n![[Pasted image 20250111033521.png]]\n\n* SC creates `Persistent volume` dynamically in the background\n* Storage Backend is defined in the SC component using `provisioner` attribute. This attribute says which provisioner to be used for a specific storage platform or cloud provider to create the `Persistent volume component` out of it \n* each storage backed has own provisioner.\n* Internal provisioner - `kubernetes.io` is provided by Kubernetes itself\n* also we use `external provisioner` for other storage backend\n\nNote --> Now `Pod` directly can't use `storage class` it is used by `PVC` and `PVC` is used by `Pod` same as in case of `Persistent volume`\nalso `PVC` configuration is little different for `SC`\n\n`PVC config for SC`\n\n![[Pasted image 20250111034712.png]]\n\n* see `storageClassName` attribute\n\nSO,\n\n`Pod` ----> `PVC` ----> `SC` -----> `Persistent volume`","x":1920,"y":-280,"width":1060,"height":2100,"color":"2"},
		{"id":"5777a93c2be7cab4","type":"text","text":"# Kubernetes Volumes explained","x":665,"y":-440,"width":550,"height":80,"color":"3"}
	],
	"edges":[
		{"id":"00de52c4c63f50f9","fromNode":"31d02342c8186ff6","fromSide":"bottom","toNode":"8bfd24523fbd4c1f","toSide":"top"},
		{"id":"36eb64d78fb5c2ee","fromNode":"8bfd24523fbd4c1f","fromSide":"bottom","toNode":"fc06c63200010c0f","toSide":"top"}
	]
}